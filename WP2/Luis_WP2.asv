clc;
clear;
close all;
% Define the WGS84 reference ellipsoid (using meters as units)
spheroid = referenceEllipsoid('wgs84', 'meter');

% Initializing the satellite scenario
startTime = datetime(2025,3,02,8,23,0);
stopTime = startTime + hours(4);
sampleTime = 60;
sc = satelliteScenario(startTime,stopTime,sampleTime);


% Create an array for time samples in date format
times = startTime : seconds(sampleTime) : stopTime;

% Define constellation parameters
P = 6;                % Number of orbit planes
S = 11;                % Satellites per orbit
semiMajorAxis = 7511000; % meters
inclination = 86.4;     % degrees

% Add satellites using the constellation function
sat = createConstellation(sc, P, S, semiMajorAxis, inclination);

% Set Turin's coordinates for the fixed GU
gs_lat = 45.07;
gs_long = 7.69;
gs_alt = 0;

% Define the GS (GU) in the Geodetic Coordinates
gs = groundStation(sc, gs_lat, gs_long);

% Exctract the GS position in ECEF coordinates  
gs_ecef_pos = lla2ecef([gs_lat, gs_long, gs_alt]);
gs_ecef_pos_time = repmat(gs_ecef_pos' , 1, numel(times));

% Define dimensions
num_times = numel(times);
num_sats = numel(sat);

% Define array to store positions of satellites through time (3D: 3 coords × times × satellites)
all_sat_pos = zeros(3, num_times, num_sats);
all_sat_pos = states(sat, "CoordinateFrame","ecef");

% Define array for Access status to signal visibility between GS and sats
ac = access(sat, gs);
intvls = accessIntervals(ac);

% Initialize status array to store logical access status at each time
status = false(num_times, num_sats);  % Preallocate with logical false

% Extract status for each time step
for j = 1:num_times
    status(j, :) = accessStatus(ac, times(j));  % Store logical status for each satellite
end

% Define the number of closest satellites to find
n = 3; 


% Preallocate matrices to store data for n closest satellites
closest_sat_coords = zeros(num_times, n, 3); % 3D matrix: num_times x n x 3 (for x,y,z)
closest_sat_indices = zeros(num_times, n);   % 2D matrix: num_times x n (for satellite indices)
closest_sat_dists = zeros(num_times, n);     % 2D matrix: num_times x n (for distances in meters)
closest_sat_elevations = zeros(num_times, n); % 2D matrix: num_times x n (for elevation angles in degrees)

% Find the n closest satellites at each time and store their data + elevation
fprintf('Calculating closest satellites and elevation angles...\n'); % Progress indicator
for j = 1:numel(times)
    active_sats = find(status(j, :));
    gs_pos = gs_ecef_pos_time(:, j); % GS ECEF position at current time - Still needed for distance/vector calc

    if ~isempty(active_sats)
        % Calculate distances only for active satellites
        distances = zeros(1, length(active_sats));
        sat_positions_active = zeros(3, length(active_sats)); % Store positions temporarily
        for k = 1:length(active_sats)
            sat_idx = active_sats(k);
            sat_pos = all_sat_pos(:, j, sat_idx);
            sat_positions_active(:, k) = sat_pos; % Store position for later use
            distances(k) = norm(gs_pos - sat_pos);
        end

        % Sort distances to find the n closest satellites
        [sorted_dists, dist_idx] = sort(distances);
        % Limit to n or the number of active satellites, whichever is smaller
        num_closest = min(n, length(active_sats));
        closest_sats_indices_in_active = dist_idx(1:num_closest); % Indices within the 'active_sats' array
        closest_sats = active_sats(closest_sats_indices_in_active); % Actual satellite indices (1 to num_sats)
        closest_dists = sorted_dists(1:num_closest);

        % ***** REMOVED ecef2lla call *****
        % No need to calculate lat/lon here, use gs_lat and gs_long directly

        % Store ECEF coordinates, indices, distances, and calculate elevation
        for k = 1:num_closest
            sat_idx = closest_sats(k); % The actual satellite index
            sat_pos = sat_positions_active(:, closest_sats_indices_in_active(k)); % Retrieve stored position

            % Store data
            closest_sat_coords(j, k, :) = sat_pos;                      % Coordinates
            closest_sat_indices(j, k) = sat_idx;                        % Satellite index
            closest_sat_dists(j, k) = closest_dists(k);                 % Distance in meters

            % Calculate elevation angle using gs_lat and gs_long
            sat_vec = sat_pos - gs_pos; % Line-of-sight vector from GS to satellite

            % ***** USING gs_lat and gs_long directly in ecef2enu *****
            sat_vec_enu = ecef2enu(sat_vec(1), sat_vec(2), sat_vec(3), gs_lat, gs_long, gs_alt, spheroid); % Transform to ENU
            
            % Check for potential division by zero if norm is extremely small (unlikely here)
            norm_sat_vec_enu = norm(sat_vec_enu);
            if norm_sat_vec_enu > eps % Use eps (floating-point relative accuracy) as threshold
                elevation = asind(sat_vec_enu(3) / norm_sat_vec_enu); % Elevation angle
            else
                elevation = 0; % Or NaN, depending on how you want to handle zero vector case
            end
            closest_sat_elevations(j, k) = elevation;                   % Store elevation
        end
        % Remaining slots (if num_closest < n) are already zero due to preallocation

    else
        % fprintf('At time %s, no satellite has access\n', string(times(j))); % Optional: reduce console output
        % Row remains zeros for this time step in all matrices
    end

    % Optional: Add progress update to console
    if mod(j, round(num_times/10)) == 0 || j == num_times
        fprintf('Processed %d/%d time steps (%.0f%%)\n', j, num_times, (j/num_times)*100);
    end
end
fprintf('Calculations complete.\n');

% --- Rest of your code (display, visualization, function definition) ---



% Optional: Display a sample of the stored data for verification (including elevation)
time_step_to_display = 60; % Example time step
fprintf('\nSample data for n=%d closest satellites at time step %d:\n', n, time_step_to_display);
fprintf('Satellite Indices:\n');
disp(closest_sat_indices(time_step_to_display, :));
fprintf('Distances (km):\n');
disp(closest_sat_dists(time_step_to_display, :) / 1000); % Convert to km
fprintf('Elevation Angles (degrees):\n');
disp(closest_sat_elevations(time_step_to_display, :));
fprintf('ECEF Coordinates (m):\n');
disp(squeeze(closest_sat_coords(time_step_to_display, :, :))); % Display as n x 3 matrix



% Visualize (optional)
% show(sat);
% groundTrack(sat, LeadTime=7200);
% play(sc);

% Highlight ground station
% gs.MarkerColor = [1 0 0]; % Red marker for ground station

% Function definition remains the same
% function sat = createConstellation(sc, P, S, semiMajorAxis, inclination) ... end


% Visualize (optional)
% show(sat);
% groundTrack(sat, LeadTime=7200);
play(sc);
% Highlight ground station
gs.MarkerColor = [1 0 0]; % Red marker for ground station

function sat = createConstellation(sc, P, S, semiMajorAxis, inclination)
    % Total number of satellites
    total_sats = P * S;
    
    % Define constant orbital parameters for all satellites
    eccentricity = zeros(1, total_sats);           % Circular orbits with eccentricitt set to zero
    argumentOfPerigee = zeros(1, total_sats);      % Arbitrary for circular orbits, set to 0
    semiMajorAxis = repmat(semiMajorAxis, 1, total_sats); % Same for all
    inclination = repmat(inclination, 1, total_sats);     % Same for all
    
    % Compute RAAN: repeat each plane's RAAN for S satellites
    RAAN = repelem((0:P-1) * 180 / P, S);
    
    % Compute true anomaly: repeat the sequence [0, 360/S, ..., (S-1)*360/S] for P planes
    trueAnomaly = repmat((0:S-1) * 360 / S, 1, P);
    
    % Create the satellite array
    sat = satellite(sc, semiMajorAxis, eccentricity, inclination, RAAN, ...
                    argumentOfPerigee, trueAnomaly);
end

