clc;
clear;
close all;

% Initializing the satellite scenario
startTime = datetime(2025,3,02,8,23,0);
stopTime = startTime + hours(4);
sampleTime = 60;
sc = satelliteScenario(startTime,stopTime,sampleTime);

% Create an array for time samples in date format
times = startTime : seconds(sampleTime) : stopTime;

% Define constellation parameters
P = 6;                % Number of orbit planes
S = 11;                % Satellites per orbit
semiMajorAxis = 7511000; % meters
inclination = 86.4;     % degrees

% Add satellites using the constellation function
sat = createConstellation(sc, P, S, semiMajorAxis, inclination);

% Set Turin's coordinates for the fixed GU
gu_lat = 45.07;
gu_long = 7.69;
gu_alt = 0;

% Define the GS (GU) in the Geodetic Coordinates
gs = groundStation(sc, gu_lat, gu_long);

% Exctract the GS position in ECEF coordinates  
gs_ecef_pos = lla2ecef([gu_lat, gu_long, gu_alt]);
gs_ecef_pos_time = repmat(gs_ecef_pos' , 1, numel(times));

% Define dimensions
num_times = numel(times);
num_sats = numel(sat);

% Define array to store positions of satellites through time (3D: 3 coords × times × satellites)
all_sat_pos = zeros(3, num_times, num_sats);
all_sat_pos = states(sat, "CoordinateFrame","ecef");

% Define array for Access status to signal visibility between GS and sats
ac = access(sat, gs);
intvls = accessIntervals(ac);

% Initialize status array to store logical access status at each time
status = false(num_times, num_sats);  % Preallocate with logical false

% Extract status for each time step
for j = 1:num_times
    status(j, :) = accessStatus(ac, times(j));  % Store logical status for each satellite
end

% Define the number of closest satellites to find
n = 3; 

% Preallocate 3D matrix to store ECEF coordinates of n closest satellites
closest_sat_coords = zeros(num_times, n, 3); % Dimensions: num_times x n x 3 (for x,y,z)

% Preallocate matrices to store data for n closest satellites
closest_sat_coords = zeros(num_times, n, 3); % 3D matrix: num_times x n x 3 (for x,y,z)
closest_sat_indices = zeros(num_times, n);   % 2D matrix: num_times x n (for satellite indices)
closest_sat_dists = zeros(num_times, n);     % 2D matrix: num_times x n (for distances in meters)

% Find the n closest satellites at each time and store their coordinates
for j = 1:numel(times)
    active_sats = find(status(j, :));
    if ~isempty(active_sats)
        distances = zeros(1, length(active_sats));
        for k = 1:length(active_sats)
            sat_idx = active_sats(k);
            sat_pos = all_sat_pos(:, j, sat_idx);
            gs_pos = gs_ecef_pos_time(:, j);
            distances(k) = norm(gs_pos - sat_pos);
        end
        % Sort distances to find the n closest satellites
        [sorted_dists, dist_idx] = sort(distances);
        % Limit to n or the number of active satellites, whichever is smaller
        num_closest = min(n, length(active_sats));
        closest_sats = active_sats(dist_idx(1:num_closest));
        closest_dists = sorted_dists(1:num_closest);
        
        % Store ECEF coordinates of the closest satellites in 3D matrix
        for k = 1:num_closest
            sat_idx = closest_sats(k);
            closest_sat_coords(j, k, :) = all_sat_pos(:, j, sat_idx);
        end
        % Remaining slots (if num_closest < n) are already zero due to preallocation
    else
        fprintf('At time %s, no satellite has access\n', string(times(j)));
        % Row remains zeros for this time step
    end
end

% Optional: Display a sample of the stored coordinates for verification
fprintf('Sample ECEF coordinates of n=%d closest satellites at first time step:\n', n);
disp(squeeze(closest_sat_coords(1, :, :))); % Display as n x 3 matrix for first time step

% Visualize (optional)
% show(sat);
% groundTrack(sat, LeadTime=7200);
play(sc);
% Highlight ground station
gs.MarkerColor = [1 0 0]; % Red marker for ground station

function sat = createConstellation(sc, P, S, semiMajorAxis, inclination)
    % Total number of satellites
    total_sats = P * S;
    
    % Define constant orbital parameters for all satellites
    eccentricity = zeros(1, total_sats);           % Circular orbits with eccentricitt set to zero
    argumentOfPerigee = zeros(1, total_sats);      % Arbitrary for circular orbits, set to 0
    semiMajorAxis = repmat(semiMajorAxis, 1, total_sats); % Same for all
    inclination = repmat(inclination, 1, total_sats);     % Same for all
    
    % Compute RAAN: repeat each plane's RAAN for S satellites
    RAAN = repelem((0:P-1) * 180 / P, S);
    
    % Compute true anomaly: repeat the sequence [0, 360/S, ..., (S-1)*360/S] for P planes
    trueAnomaly = repmat((0:S-1) * 360 / S, 1, P);
    
    % Create the satellite array
    sat = satellite(sc, semiMajorAxis, eccentricity, inclination, RAAN, ...
                    argumentOfPerigee, trueAnomaly);
end

